We learned how to define resoures and use them as inputs in our job plans. Often we will want to also publish the output of our jobs as well.

In this step, we will create a slightly more complex pipeline which commits changes to a git resource and pushes these changes back to the external resource. Side note: External is not really the right term here as we run the git remote **within** our learning environment.

In the "Task Basics" scenario we looked at extracting complex run commands into standalone shell scripts. Similarly, for job steps of type `task`, we may inline the task configuration as we did previously or refer to an external file containing the task configuration using, in this case, the `file` key.

```
  ...
  plan:
  ...
  - task: bump-timestamp-file
    file: resource-git-sample/ci/task-bump-timestamp.yml
  ...
```

With pipelines we now need to store the task file and task script somewhere outside of Concourse. The most common resource type to store our task files and task scripts is the `git` resource type. Perhaps your task files could be fetched via the `s3` resource type from an AWS S3 bucket; or the `archive` resource type to extract them from a remote archive file. Or perhaps the task files could be pre-baked into the `image_resource` base Docker image.

In our use case, our task file `git-sample/ci/task-bump-timestamp.yml`{{open}} and task script `git-sample/ci/bump-timestamp.sh`{{open}} are stored in our project git repository. The task script will fork the git repository to `updated-git-sample` folder and bump the date in the `bumpme` file, committing the change when done.

Create a new pipeline configuration via the CLI: `touch pipeline_output_git.yml`{{execute}}

Open the file: `pipeline_output_git.yml`{{open}}

Add the following pipeline configuration which is similar to previous pipelines, but the task config is not in-line, referring to a `file` instead:

<pre class="file" data-filename="pipeline_output_git.yml" data-target="replace">
resources:
- name: resource-git-sample
  type: git
  source:
    uri: http://git-server:8080/git-sample.git
    branch: master

jobs:
- name: job-bump-date
  serial: true
  plan:
  - get: resource-git-sample
  - task: bump-timestamp-file
    file: resource-git-sample/ci/task-bump-timestamp.yml
</pre>

Finally, to push the `updated-git-sample` generated by `bump-timestamp.sh` script, add a `put` step to the job plan, with `repository` being the only required parameter:

<pre class="file" data-filename="pipeline_output_git.yml" data-target="append">  - put: resource-git-sample
    params:
      repository: updated-git-sample
</pre>

Refer to the [concourse/git-resource](https://github.com/concourse/git-resource#out-push-to-a-repository) documentation for an overview of all the parameters supported for publishing this resource.

Create the new pipeline as `bump-date`:

```
fly -t tutorial sp -p bump-date -c pipeline_output_git.yml
```{{execute}}

Unpause the `bump-date` pipeline:

```
fly -t tutorial up -p bump-date
```{{execute}}

And trigger the job with the `-w` flag to watch its progress:

```
fly -t tutorial tj -j bump-date/job-bump-date -w
```{{execute}}

To confirm the job worked as expected, pull and review the changes made by concourse in your local repository:

```
cd git-sample
git pull
git log --pretty=format:"%h%x09%ad%x09%s by %an"
git diff HEAD~1 HEAD
cd -
```{{execute}}

The name of resources and the name of task outputs, determine the name used to access them by other tasks.

The `bump-timestamp-file` task can access anything from `resource-git-sample` under the `resource-git-sample/` path. Since the relative path of `task-bump-timestamp.yml` task file inside this repo is `ci/task-bump-timestamp.yml`, the task: `bump-timestamp-file` references it by joining the two: `file: resource-git-sample/ci/task-bump-timestamp.yml`

There is a benefit and a downside to abstracting tasks into YAML files outside of the pipeline.

One benefit is that the behavior of the task can be kept in sync with the primary input resource (for example, a software project with tasks for running tests, building binaries, etc).

One downside is that the `pipeline.yml` no longer explains exactly what commands will be invoked. Comprehension of pipeline behavior is potentially reduced.

But one benefit of extracting inline tasks into task files is that `pipeline.yml` files can get long and it can be hard to read and comprehend all the YAML. Instead, give tasks long names so that readers can understand what the purpose and expectation of the task is at a glance.

But one downside of extracting inline tasks into files is that `fly set-pipeline` is no longer the only step to updating a pipeline.

From now onwards, any change to your pipeline might require you to do one or both:

- Update concourse with `fly set-pipeline` on a change to the job build plan and/or input/output resources
- Update your primary source of task files and task scripts with `git commit` and `git push`

If a pipeline is not performing new behaviour then it might be you skipped one of the two steps above.

Due to the benefits vs downsides of the two approaches - inline task configuration vs YAML file task configuration - you will see both approaches used in the wider community of Concourse users.
